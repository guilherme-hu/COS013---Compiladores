// roda exemplo vazio para ver inputs (let, if, for, while, array e objeto)
// array e objeto (map) usam [@] e [=] -> let a ={}; A.n = 2 equivale a A['N'], não pode ser numero (A.1) ->podemos considerar A.n como alias de A['n']
//      array é tipo especial de object, por isso tem seus metodos. array não mostra campos quando converte para string
//      usar b[10] para object cria um espaço no map 
// b = a.n +1 -> b a @ n [@] 1 + = ;  a @ para pegar obj a, n [@] para pegar o campo n do objeto no topo da pilha
//      o que é empilhado é o ponteiro para o objeto a, não seu conteudo
// quando encontrar ; , colocar \n

// LVALUE = left value (o que pode estar do lado esquerdo de uma atribuição -> qualquer coisa que tem endereço, pode ter valor)
// RVALUE = right value (o que pode estar do lado direito de uma atribuição -> qualquer coisa que tem valor)

// jumpTrue -> faz comparação e pula pro endereço no topo da pilha -> faremos por label, para ver endereço de blocos e fazer jump -> gera codigo antes e depois varre codigo resolvendo labels, duas varreduras
// jumpFalse -> colocar ! (not) no final -> if (a>2) => a@ 2 > ! 
// duas defs -> criando label e usando label, labels não podem se repetir -> ID sequencial (n++ de var global) -> ver codigo de fazendo if

// resolução de endereços -> vector de string e vai fazendo push_back de cada linha
// :label, def_label (definindo label) / label:, use_label (usando label)
// colocar rotulo; codigo e novo codigo, quando encontrar use_label copia, quando encontrar def_label coloca no map o numero onde ele tem que apontar
// função concatena para juntar comandos do codigo (ver ativ de resolução de endereços)

// redefinir operador + para aceitar soma de string 

concatena
operator+ (codigos no moodle)

gera label()
resolve endereço() // copiar função do moodle

int main(){
    vector<string> ssc, s1c, s2c; //ssc = codigo
    s1c.pushback('a');
    s2c.pushback('@');

    ssc = s1c +s2c + '=' + '^';

    for(auto x: ssc){
        cout << x << " ";
    }

    string fim_if = gera_label("fim_if"); // fim_if + :
    string define_fim_if = ":" + fim_if;

    ssc = s1c +s2c + ">" +  fim_if + '?';
    ssc = ssc + "x" + "&" + '1' + '2' + '*' + '=' + '^';
    ssc = ssc + define_fim_if + '.'; // definir label

    for(auto x: resolve_endereços(ssc)){
        cout << x << " ";
    }
}

hdksvv: usando endereço
:kjvskjsd definindo endereço, essa é a linha que eu vou saltar


%{
int linha = 1;
int coluna = 1;
string lexema;
%}

{DOUBLE} { lexema = yytext;
           coluna += lexema.size();
            return DOUBLE; }


BAIT:

let a = 1;
let b = {};
b.c = a++;
b.d = b.c++;


TESTES:

Incorrect program output
--- Input ---
let a = 1, b, x;
x = b = a * (8 + 1.1);
let c = "hello ";
c += ", " + 'world' + '!';

--- Expected output (text)---
=== Console ===
=== Vars ===
|{ a: 1; b: 9.1; c: hello , world!; x: 9.1; }|
=== Pilha ===
"

Test 3: #3 if sem else
Incorrect program output
--- Input ---
let a = 4, b = 5, c, d;
if( a++ > b )
  c = "a e' maior"
      + "!";
if( a < b + 1 )
  d = "a e' menor";

--- Expected output (exact text)---
=== Console ===
=== Vars ===
|{ a: 5; b: 5; c: undefined; d: a e' menor; }|
=== Pilha ===


Test 4: #4 if com else
Incorrect program output
--- Input ---
let a = "ABA", c = 'CATE', resultado;
if( a == c )
  resultado = "Ta' errado!";
else if( a < c ) 
{
  resultado = "a vem antes de c: ";
  resultado += a + '<' + c ;
}
else
  resultado = "Deu ruim!";

--- Expected output (exact text)---
=== Console ===
=== Vars ===
|{ a: ABA; c: CATE; resultado: a vem antes de c: ABA<CATE; }|
=== Pilha ===


Test 5: #5 Objetos e arrays
Incorrect program output
--- Input ---
let obj = {}, i = -2;
obj.nome = "Manoel";
obj.nums = [];
obj.nums[0] 
= 12 ;
obj.nums[3] = 12 ;
obj.nums[3] += 1 ;
obj.nums[i++ + 3] = 45;
obj['nom' + 'e'] = obj.nome + "!";

--- Expected output (exact text)---
=== Console ===
=== Vars ===
|{ i: -1; obj: { nome: Manoel!; nums: [ 0: 12; 1: 45; 2: undefined; 3: 13; ]; }; }|
=== Pilha ===


Test 6: #6 while
Incorrect program output
--- Input ---
let i = 0, j = -1, x = 9, b = [];
while( i < x - 2*3 + 2.1 ) {
  b[i] = j;
  i = i + 1;
  j = i / 2.0 + j;
};
j = x = 0;

--- Expected output (exact text)---
=== Console ===
=== Vars ===
|{ b: [ 0: -1; 1: -0.5; 2: 0.5; 3: 2; 4: 4; 5: 6.5; ]; i: 6; j: 0; x: 0; }|
=== Pilha ===


Test 7: #7 for
Incorrect program output
--- Input ---
let a = {}, campo = "c";

for( let i = 0; i < 6; i = i + 2 ) {
  a[campo = campo + i] = i;
};

--- Expected output (exact text)---
=== Console ===
=== Vars ===
|{ a: { c0: 0; c02: 2; c024: 4; }; campo: c024; i: 6; }|
=== Pilha ===


Test 8: #8 multiplicação de matrizes
Incorrect program output
--- Input ---
let a = [], b = [], c = [];
let i, j, k;
for( i = 0; i < 4; i = i + 1 ) {
  a[i] = []; 
  b[i] = [];
  for( j = 0; j < 4; j += 1 ) {
    a[i][j] = b[i][j] = 1.1/(i+j+1.0);;
  }
}

for( i = 0; i < 4; i = i + 1 ) {
  c[i] = [];
  for( j = 0; j < 4; j = j + 1 ) {
    c[i][j] = 0;
    for( k = 0; k < 4; k = k + 1 ) {
      c[i][j] = c[i][j] + a[i][k] * b[k][j]; 
    }
  }
}  

--- Expected output (exact text)---
=== Console ===
=== Vars ===
|{ a: [ 0: [ 0: 1.1; 1: 0.55; 2: 0.366667; 3: 0.275; ]; 1: [ 0: 0.55; 1: 0.366667; 2: 0.275; 3: 0.22; ]; 2: [ 0: 0.366667; 1: 0.275; 2: 0.22; 3: 0.183333; ]; 3: [ 0: 0.275; 1: 0.22; 2: 0.183333; 3: 0.157143; ]; ]; b: [ 0: [ 0: 1.1; 1: 0.55; 2: 0.366667; 3: 0.275; ]; 1: [ 0: 0.55; 1: 0.366667; 2: 0.275; 3: 0.22; ]; 2: [ 0: 0.366667; 1: 0.275; 2: 0.22; 3: 0.183333; ]; 3: [ 0: 0.275; 1: 0.22; 2: 0.183333; 3: 0.157143; ]; ]; c: [ 0: [ 0: 1.72257; 1: 0.968; 2: 0.685667; 3: 0.533937; ]; 1: [ 0: 0.968; 1: 0.560969; 2: 0.403333; 3: 0.316905; ]; 2: [ 0: 0.685667; 1: 0.403333; 2: 0.292081; 3: 0.230476; ]; 3: [ 0: 0.533937; 1: 0.316905; 2: 0.230476; 3: 0.18233; ]; ]; i: 4; j: 4; k: 4; }|
=== Pilha ===


Test 9: #9 Variável não declarada
Incorrect program output
--- Input ---
let a = 1, x = '9';
b = 10;

--- Expected output (exact text)---
Erro: a variável 'b' não foi declarada.
=== Console ===
=== Vars ===
|{ }|
=== Pilha ===


Test 10: #10 Declaração duplicada da mesma variável
Incorrect program output
--- Input ---
let a = {}, b = [], c = 9;
let a;

--- Expected output (exact text)---
Erro: a variável 'a' ja foi declarada na linha 1.
=== Console ===
=== Vars ===
|{ }|
=== Pilha ===

